{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Saleor App Framework \u00b6 You are reading the Saleor App Framework (Python) documentation. This document should help you to quickly bootstrap a 3 rd Party Saleor App, read more about those image/svg+xml Saleor's documentation . The only supported web framework is FastAPI . Quickstart \u00b6 Install the framework \u00b6 Using Poetry (recommended, installing poetry ): poetry add git+https://github.com/mirumee/saleor-app-framework-python.git@main # (1) Not on PyPi yet, you must install from git Using Pip: pip install git+https://github.com/mirumee/saleor-app-framework-python.git@main Create the Saleor app \u00b6 To run your Saleor App you can use the SaleorApp class which overloads the usual FastAPI class. 1 2 3 4 5 from saleor_app.app import SaleorApp app = SaleorApp ( # more arguments to come ) You can use the app instance as you would normally use the standard one, i.e. to initialize Sentry or add Middleware. None of the core FastAPI logic is changed by the framework. Manifest \u00b6 As described in image/svg+xml App manifest an app needs a manifest, the framework provides a Pydantic representation of that which needs to be provided when initializing the app. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from saleor_app.app import SaleorApp from saleor_app.schemas.manifest import Manifest from saleor_app.schemas.utils import LazyUrl manifest = Manifest ( name = \"Sample Saleor App\" , version = \"0.1.0\" , about = \"Sample Saleor App seving as an example.\" , data_privacy = \"\" , data_privacy_url = \"http://samle-saleor-app.example.com/dataPrivacyUrl\" , homepage_url = \"http://samle-saleor-app.example.com/homepageUrl\" , support_url = \"http://samle-saleor-app.example.com/supportUrl\" , id = \"saleor-simple-sample\" , permissions = [ \"MANAGE_PRODUCTS\" , \"MANAGE_USERS\" ], configuration_url = LazyUrl ( \"configuration-form\" ), extensions = [], ) app = SaleorApp ( manifest = manifest , # more arguments to come ) LazyUrl saleor_app . schemas . utils . LazyUrl is a lazy loader for app url paths, when a manifest is requested the app will resolve the path name to a full url of that endpoint. Validate Domain \u00b6 3 rd Patry Apps work in a multi-tenant fashion - one app service can serve multiple Saleor instances. To prevent any Saleor instance from using your app the app need to authorize a Saleor instance that's done by a simple function that can be as simple as comparing the incoming Saleor domain or as complex to check the allowed domains in a database. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from saleor_app.app import SaleorApp from saleor_app.schemas.core import DomainName from saleor_app.schemas.manifest import Manifest from saleor_app.schemas.utils import LazyUrl async def validate_domain ( saleor_domain : DomainName ) -> bool : return saleor_domain == \"172.17.0.1:8000\" manifest = Manifest ( name = \"Sample Saleor App\" , version = \"0.1.0\" , about = \"Sample Saleor App seving as an example.\" , data_privacy = \"\" , data_privacy_url = \"http://samle-saleor-app.example.com/dataPrivacyUrl\" , homepage_url = \"http://samle-saleor-app.example.com/homepageUrl\" , support_url = \"http://samle-saleor-app.example.com/supportUrl\" , id = \"saleor-simple-sample\" , permissions = [ \"MANAGE_PRODUCTS\" , \"MANAGE_USERS\" ], configuration_url = LazyUrl ( \"configuration-form\" ), extensions = [], ) app = SaleorApp ( manifest = manifest , validate_domain = validate_domain , # more arguments to come ) Saving Application Data \u00b6 When Saleor is authorized to install the app an authentication key is issued, that key needs to be securely stored by the app as it provides as much access as the app requested in the manifest. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from saleor_app.app import SaleorApp from saleor_app.schemas.core import DomainName , WebhookData from saleor_app.schemas.manifest import Manifest from saleor_app.schemas.utils import LazyUrl async def validate_domain ( saleor_domain : DomainName ) -> bool : return saleor_domain == \"172.17.0.1:8000\" async def store_app_data ( saleor_domain : DomainName , auth_token : str , webhook_data : WebhookData ): print ( \"Called store_app_data\" ) print ( saleor_domain ) print ( auth_token ) print ( webhook_data ) # manifest = Manifest ( name = \"Sample Saleor App\" , version = \"0.1.0\" , about = \"Sample Saleor App serving as an example.\" , data_privacy = \"\" , data_privacy_url = \"http://sample-saleor-app.example.com/dataPrivacyUrl\" , homepage_url = \"http://sample-saleor-app.example.com/homepageUrl\" , support_url = \"http://sample-saleor-app.example.com/supportUrl\" , id = \"saleor-simple-sample\" , permissions = [ \"MANAGE_PRODUCTS\" , \"MANAGE_USERS\" ], configuration_url = LazyUrl ( \"configuration-form\" ), extensions = [], ) app = SaleorApp ( manifest = manifest , validate_domain = validate_domain , save_app_data = store_app_data , # (1) ) Typically, you'd store all the data passed to this function to a DB table Configuration URL \u00b6 To finalize, you need to provide the endpoint named configuration - form specified in the #Manifest . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 import json from fastapi.param_functions import Depends from fastapi.responses import HTMLResponse , PlainTextResponse from saleor_app.app import SaleorApp from saleor_app.deps import ConfigurationFormDeps from saleor_app.schemas.core import DomainName , WebhookData from saleor_app.schemas.manifest import Manifest from saleor_app.schemas.utils import LazyUrl async def validate_domain ( saleor_domain : DomainName ) -> bool : return saleor_domain == \"172.17.0.1:8000\" async def store_app_data ( saleor_domain : DomainName , auth_token : str , webhook_data : WebhookData ): print ( \"Called store_app_data\" ) print ( saleor_domain ) print ( auth_token ) print ( webhook_data ) manifest = Manifest ( name = \"Sample Saleor App\" , version = \"0.1.0\" , about = \"Sample Saleor App seving as an example.\" , data_privacy = \"\" , data_privacy_url = \"http://samle-saleor-app.example.com/dataPrivacyUrl\" , homepage_url = \"http://samle-saleor-app.example.com/homepageUrl\" , support_url = \"http://samle-saleor-app.example.com/supportUrl\" , id = \"saleor-simple-sample\" , permissions = [ \"MANAGE_PRODUCTS\" , \"MANAGE_USERS\" ], configuration_url = LazyUrl ( \"configuration-form\" ), extensions = [], ) app = SaleorApp ( manifest = manifest , validate_domain = validate_domain , save_app_data = store_app_data , ) @app . configuration_router . get ( \"/\" , response_class = HTMLResponse , name = \"configuration-form\" ) async def get_public_form ( commons : ConfigurationFormDeps = Depends ()): context = { \"request\" : str ( commons . request ), \"form_url\" : str ( commons . request . url ), \"saleor_domain\" : commons . saleor_domain , } return PlainTextResponse ( json . dumps ( context , indent = 4 )) # (1) app . include_saleor_app_routes () # (2) This view would normally return a UI that will be rendered in the Dashboard Once you are done defining all the configuration routes you need to tell the app to load them This is a complete example that will work as is. Remember about app.include_saleor_app_routes() Running the App \u00b6 To run the app you can save the above example in simple_app/app.py and run it with: uvicorn simple_app.app:app --host 0 .0.0.0 --port 5000 --reload Or create a simple_app/__main__.py with: 1 2 3 4 5 6 7 8 9 10 11 import uvicorn def main (): uvicorn . run ( \"simple_app.app:app\" , host = \"0.0.0.0\" , port = 5000 , debug = True , reload = True ) if __name__ == \"__main__\" : main () and run the module as a script with Python's -m flag: python -m simple_app Examples \u00b6 Visit the Samples directory to check apps that were built as examples of how the framework can be used.","title":"Welcome to Saleor App Framework"},{"location":"#welcome-to-saleor-app-framework","text":"You are reading the Saleor App Framework (Python) documentation. This document should help you to quickly bootstrap a 3 rd Party Saleor App, read more about those image/svg+xml Saleor's documentation . The only supported web framework is FastAPI .","title":"Welcome to Saleor App Framework"},{"location":"#quickstart","text":"","title":"Quickstart"},{"location":"#install-the-framework","text":"Using Poetry (recommended, installing poetry ): poetry add git+https://github.com/mirumee/saleor-app-framework-python.git@main # (1) Not on PyPi yet, you must install from git Using Pip: pip install git+https://github.com/mirumee/saleor-app-framework-python.git@main","title":"Install the framework"},{"location":"#create-the-saleor-app","text":"To run your Saleor App you can use the SaleorApp class which overloads the usual FastAPI class. 1 2 3 4 5 from saleor_app.app import SaleorApp app = SaleorApp ( # more arguments to come ) You can use the app instance as you would normally use the standard one, i.e. to initialize Sentry or add Middleware. None of the core FastAPI logic is changed by the framework.","title":"Create the Saleor app"},{"location":"#manifest","text":"As described in image/svg+xml App manifest an app needs a manifest, the framework provides a Pydantic representation of that which needs to be provided when initializing the app. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from saleor_app.app import SaleorApp from saleor_app.schemas.manifest import Manifest from saleor_app.schemas.utils import LazyUrl manifest = Manifest ( name = \"Sample Saleor App\" , version = \"0.1.0\" , about = \"Sample Saleor App seving as an example.\" , data_privacy = \"\" , data_privacy_url = \"http://samle-saleor-app.example.com/dataPrivacyUrl\" , homepage_url = \"http://samle-saleor-app.example.com/homepageUrl\" , support_url = \"http://samle-saleor-app.example.com/supportUrl\" , id = \"saleor-simple-sample\" , permissions = [ \"MANAGE_PRODUCTS\" , \"MANAGE_USERS\" ], configuration_url = LazyUrl ( \"configuration-form\" ), extensions = [], ) app = SaleorApp ( manifest = manifest , # more arguments to come ) LazyUrl saleor_app . schemas . utils . LazyUrl is a lazy loader for app url paths, when a manifest is requested the app will resolve the path name to a full url of that endpoint.","title":"Manifest"},{"location":"#validate-domain","text":"3 rd Patry Apps work in a multi-tenant fashion - one app service can serve multiple Saleor instances. To prevent any Saleor instance from using your app the app need to authorize a Saleor instance that's done by a simple function that can be as simple as comparing the incoming Saleor domain or as complex to check the allowed domains in a database. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from saleor_app.app import SaleorApp from saleor_app.schemas.core import DomainName from saleor_app.schemas.manifest import Manifest from saleor_app.schemas.utils import LazyUrl async def validate_domain ( saleor_domain : DomainName ) -> bool : return saleor_domain == \"172.17.0.1:8000\" manifest = Manifest ( name = \"Sample Saleor App\" , version = \"0.1.0\" , about = \"Sample Saleor App seving as an example.\" , data_privacy = \"\" , data_privacy_url = \"http://samle-saleor-app.example.com/dataPrivacyUrl\" , homepage_url = \"http://samle-saleor-app.example.com/homepageUrl\" , support_url = \"http://samle-saleor-app.example.com/supportUrl\" , id = \"saleor-simple-sample\" , permissions = [ \"MANAGE_PRODUCTS\" , \"MANAGE_USERS\" ], configuration_url = LazyUrl ( \"configuration-form\" ), extensions = [], ) app = SaleorApp ( manifest = manifest , validate_domain = validate_domain , # more arguments to come )","title":"Validate Domain"},{"location":"#saving-application-data","text":"When Saleor is authorized to install the app an authentication key is issued, that key needs to be securely stored by the app as it provides as much access as the app requested in the manifest. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from saleor_app.app import SaleorApp from saleor_app.schemas.core import DomainName , WebhookData from saleor_app.schemas.manifest import Manifest from saleor_app.schemas.utils import LazyUrl async def validate_domain ( saleor_domain : DomainName ) -> bool : return saleor_domain == \"172.17.0.1:8000\" async def store_app_data ( saleor_domain : DomainName , auth_token : str , webhook_data : WebhookData ): print ( \"Called store_app_data\" ) print ( saleor_domain ) print ( auth_token ) print ( webhook_data ) # manifest = Manifest ( name = \"Sample Saleor App\" , version = \"0.1.0\" , about = \"Sample Saleor App serving as an example.\" , data_privacy = \"\" , data_privacy_url = \"http://sample-saleor-app.example.com/dataPrivacyUrl\" , homepage_url = \"http://sample-saleor-app.example.com/homepageUrl\" , support_url = \"http://sample-saleor-app.example.com/supportUrl\" , id = \"saleor-simple-sample\" , permissions = [ \"MANAGE_PRODUCTS\" , \"MANAGE_USERS\" ], configuration_url = LazyUrl ( \"configuration-form\" ), extensions = [], ) app = SaleorApp ( manifest = manifest , validate_domain = validate_domain , save_app_data = store_app_data , # (1) ) Typically, you'd store all the data passed to this function to a DB table","title":"Saving Application Data"},{"location":"#configuration-url","text":"To finalize, you need to provide the endpoint named configuration - form specified in the #Manifest . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 import json from fastapi.param_functions import Depends from fastapi.responses import HTMLResponse , PlainTextResponse from saleor_app.app import SaleorApp from saleor_app.deps import ConfigurationFormDeps from saleor_app.schemas.core import DomainName , WebhookData from saleor_app.schemas.manifest import Manifest from saleor_app.schemas.utils import LazyUrl async def validate_domain ( saleor_domain : DomainName ) -> bool : return saleor_domain == \"172.17.0.1:8000\" async def store_app_data ( saleor_domain : DomainName , auth_token : str , webhook_data : WebhookData ): print ( \"Called store_app_data\" ) print ( saleor_domain ) print ( auth_token ) print ( webhook_data ) manifest = Manifest ( name = \"Sample Saleor App\" , version = \"0.1.0\" , about = \"Sample Saleor App seving as an example.\" , data_privacy = \"\" , data_privacy_url = \"http://samle-saleor-app.example.com/dataPrivacyUrl\" , homepage_url = \"http://samle-saleor-app.example.com/homepageUrl\" , support_url = \"http://samle-saleor-app.example.com/supportUrl\" , id = \"saleor-simple-sample\" , permissions = [ \"MANAGE_PRODUCTS\" , \"MANAGE_USERS\" ], configuration_url = LazyUrl ( \"configuration-form\" ), extensions = [], ) app = SaleorApp ( manifest = manifest , validate_domain = validate_domain , save_app_data = store_app_data , ) @app . configuration_router . get ( \"/\" , response_class = HTMLResponse , name = \"configuration-form\" ) async def get_public_form ( commons : ConfigurationFormDeps = Depends ()): context = { \"request\" : str ( commons . request ), \"form_url\" : str ( commons . request . url ), \"saleor_domain\" : commons . saleor_domain , } return PlainTextResponse ( json . dumps ( context , indent = 4 )) # (1) app . include_saleor_app_routes () # (2) This view would normally return a UI that will be rendered in the Dashboard Once you are done defining all the configuration routes you need to tell the app to load them This is a complete example that will work as is. Remember about app.include_saleor_app_routes()","title":"Configuration URL"},{"location":"#running-the-app","text":"To run the app you can save the above example in simple_app/app.py and run it with: uvicorn simple_app.app:app --host 0 .0.0.0 --port 5000 --reload Or create a simple_app/__main__.py with: 1 2 3 4 5 6 7 8 9 10 11 import uvicorn def main (): uvicorn . run ( \"simple_app.app:app\" , host = \"0.0.0.0\" , port = 5000 , debug = True , reload = True ) if __name__ == \"__main__\" : main () and run the module as a script with Python's -m flag: python -m simple_app","title":"Running the App"},{"location":"#examples","text":"Visit the Samples directory to check apps that were built as examples of how the framework can be used.","title":"Examples"},{"location":"event_handlers/http/","text":"HTTP Webhook Event Handling \u00b6 While it's not necessary for every Saleor app to receive domain events from Saleor it is possible, as described in image/svg+xml Saleor's docs . To configure your app to listen to HTTP webhooks issued from Saleor you need to register your handlers similarly as you would register your FastAPI endpoints. Setting up the Saleor App \u00b6 Getting Webhook details \u00b6 The framework ensures that the webhook comes from a trusted source but to achieve that it needs to be provided with a way of retrieving the webhook_secret your app stored when the save_app_data was invoked (upon app installation). To do that you need to provide the SaleorApp with an async function doing just that. 1 2 3 4 5 6 7 8 from saleor_app.schemas.core import DomainName , WebhookData async def get_webhook_details ( saleor_domain : DomainName ) -> WebhookData : return WebhookData ( webhook_id = \"webhook-id\" , webhook_secret_key = \"webhook-secret-key\" , ) # (1) Typically the data would be taken from a database The function takes the saleor_domain and must return a WebhookData Pydantic model instance Enabling the webhook router \u00b6 The framework provides a special webhook router that allows you to use many different endpoints under the /webhook route. That router needs to be enabled with the get_webhook_details function: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from saleor_app.app import SaleorApp from saleor_app.schemas.core import DomainName , WebhookData async def get_webhook_details ( saleor_domain : DomainName ) -> WebhookData : return WebhookData ( webhook_id = \"webhook-id\" , webhook_secret_key = \"webhook-secret-key\" , ) app = SaleorApp ( #[...] ) app . include_webhook_router ( get_webhook_details = get_webhook_details ) Defining webhook handlers \u00b6 An HTTP webhook handler is a function that is exactly like one that one would use as a FastAPI endpoint. The difference is that we register those with a special router. An example of a HTTP webhook handler is: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from saleor_app.app import SaleorApp from saleor_app.deps import saleor_domain_header # (1) from saleor_app.schemas.handlers import SaleorEventType from saleor_app.schemas.webhook import Webhook from saleor_app.schemas.core import DomainName , WebhookData async def get_webhook_details ( saleor_domain : DomainName ) -> WebhookData : return WebhookData ( webhook_id = \"webhook-id\" , webhook_secret_key = \"webhook-secret-key\" , ) app = SaleorApp ( #[...] ) app . include_webhook_router ( get_webhook_details = get_webhook_details ) @app . webhook_router . http_event_route ( SaleorEventType . PRODUCT_CREATED ) async def product_created ( payload : List [ Webhook ], saleor_domain = Depends ( saleor_domain_header ) # (2) ): await do_something ( payload , saleor_domain ) saleor_app.deps contains a set of FastAPI dependencies that you might find useful since product_created is just a FastAPI endpoint you have access to everything a usual endpoint would, like request: Request If your app is bigger and you need to import your endpoints from a different module you can: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from saleor_app.app import SaleorApp from saleor_app.schemas.handlers import SaleorEventType from saleor_app.schemas.webhook import Webhook from saleor_app.schemas.core import DomainName , WebhookData from my_app.webhook_handlers import product_created async def get_webhook_details ( saleor_domain : DomainName ) -> WebhookData : return WebhookData ( webhook_id = \"webhook-id\" , webhook_secret_key = \"webhook-secret-key\" , ) app = SaleorApp ( #[...] ) app . include_webhook_router ( get_webhook_details = get_webhook_details ) @app . webhook_router . http_event_route ( SaleorEventType . PRODUCT_CREATED )( product_created ) Support for subscription webhook payloads \u00b6 The difference between subscriptions and the basic approach for webhook handlers is that we add an optional argument for the subscription query, and also a more general payload parameter type in the endpoint. This is because the structure of the subscription payload sent by Saelor is different in this case. You can find documentation for Saleor subscription here: Saleor's docs - subscription An example of a HTTP subscription webhook handler is: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from saleor_app.app import SaleorApp from saleor_app.deps import saleor_domain_header # (1) from saleor_app.schemas.handlers import SaleorEventType from saleor_app.schemas.webhook import Webhook from saleor_app.schemas.core import DomainName , WebhookData async def get_webhook_details ( saleor_domain : DomainName ) -> WebhookData : return WebhookData ( webhook_id = \"webhook-id\" , webhook_secret_key = \"webhook-secret-key\" , ) app = SaleorApp ( #[...] ) app . include_webhook_router ( get_webhook_details = get_webhook_details ) SUBSCRIPTION_ORDER_CREATED = \"subscription { event { ... on DraftOrderCreated { order { id status created } } } }\" @app . webhook_router . http_event_route ( SaleorEventType . ORDER_CREATED , subscription_query = SUBSCRIPTION_ORDER_CREATED ) async def order_created ( payload : Request , saleor_domain = Depends ( saleor_domain_header ) # (2) ): await do_something ( payload , saleor_domain ) Reinstall the app \u00b6 Neither Saleor nor the app will automatically update the registered webhooks, you need to reinstall the app in Saleor if it was already installed.","title":"HTTP Webhook Event Handling"},{"location":"event_handlers/http/#http-webhook-event-handling","text":"While it's not necessary for every Saleor app to receive domain events from Saleor it is possible, as described in image/svg+xml Saleor's docs . To configure your app to listen to HTTP webhooks issued from Saleor you need to register your handlers similarly as you would register your FastAPI endpoints.","title":"HTTP Webhook Event Handling"},{"location":"event_handlers/http/#setting-up-the-saleor-app","text":"","title":"Setting up the Saleor App"},{"location":"event_handlers/http/#getting-webhook-details","text":"The framework ensures that the webhook comes from a trusted source but to achieve that it needs to be provided with a way of retrieving the webhook_secret your app stored when the save_app_data was invoked (upon app installation). To do that you need to provide the SaleorApp with an async function doing just that. 1 2 3 4 5 6 7 8 from saleor_app.schemas.core import DomainName , WebhookData async def get_webhook_details ( saleor_domain : DomainName ) -> WebhookData : return WebhookData ( webhook_id = \"webhook-id\" , webhook_secret_key = \"webhook-secret-key\" , ) # (1) Typically the data would be taken from a database The function takes the saleor_domain and must return a WebhookData Pydantic model instance","title":"Getting Webhook details"},{"location":"event_handlers/http/#enabling-the-webhook-router","text":"The framework provides a special webhook router that allows you to use many different endpoints under the /webhook route. That router needs to be enabled with the get_webhook_details function: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from saleor_app.app import SaleorApp from saleor_app.schemas.core import DomainName , WebhookData async def get_webhook_details ( saleor_domain : DomainName ) -> WebhookData : return WebhookData ( webhook_id = \"webhook-id\" , webhook_secret_key = \"webhook-secret-key\" , ) app = SaleorApp ( #[...] ) app . include_webhook_router ( get_webhook_details = get_webhook_details )","title":"Enabling the webhook router"},{"location":"event_handlers/http/#defining-webhook-handlers","text":"An HTTP webhook handler is a function that is exactly like one that one would use as a FastAPI endpoint. The difference is that we register those with a special router. An example of a HTTP webhook handler is: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from saleor_app.app import SaleorApp from saleor_app.deps import saleor_domain_header # (1) from saleor_app.schemas.handlers import SaleorEventType from saleor_app.schemas.webhook import Webhook from saleor_app.schemas.core import DomainName , WebhookData async def get_webhook_details ( saleor_domain : DomainName ) -> WebhookData : return WebhookData ( webhook_id = \"webhook-id\" , webhook_secret_key = \"webhook-secret-key\" , ) app = SaleorApp ( #[...] ) app . include_webhook_router ( get_webhook_details = get_webhook_details ) @app . webhook_router . http_event_route ( SaleorEventType . PRODUCT_CREATED ) async def product_created ( payload : List [ Webhook ], saleor_domain = Depends ( saleor_domain_header ) # (2) ): await do_something ( payload , saleor_domain ) saleor_app.deps contains a set of FastAPI dependencies that you might find useful since product_created is just a FastAPI endpoint you have access to everything a usual endpoint would, like request: Request If your app is bigger and you need to import your endpoints from a different module you can: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from saleor_app.app import SaleorApp from saleor_app.schemas.handlers import SaleorEventType from saleor_app.schemas.webhook import Webhook from saleor_app.schemas.core import DomainName , WebhookData from my_app.webhook_handlers import product_created async def get_webhook_details ( saleor_domain : DomainName ) -> WebhookData : return WebhookData ( webhook_id = \"webhook-id\" , webhook_secret_key = \"webhook-secret-key\" , ) app = SaleorApp ( #[...] ) app . include_webhook_router ( get_webhook_details = get_webhook_details ) @app . webhook_router . http_event_route ( SaleorEventType . PRODUCT_CREATED )( product_created )","title":"Defining webhook handlers"},{"location":"event_handlers/http/#support-for-subscription-webhook-payloads","text":"The difference between subscriptions and the basic approach for webhook handlers is that we add an optional argument for the subscription query, and also a more general payload parameter type in the endpoint. This is because the structure of the subscription payload sent by Saelor is different in this case. You can find documentation for Saleor subscription here: Saleor's docs - subscription An example of a HTTP subscription webhook handler is: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from saleor_app.app import SaleorApp from saleor_app.deps import saleor_domain_header # (1) from saleor_app.schemas.handlers import SaleorEventType from saleor_app.schemas.webhook import Webhook from saleor_app.schemas.core import DomainName , WebhookData async def get_webhook_details ( saleor_domain : DomainName ) -> WebhookData : return WebhookData ( webhook_id = \"webhook-id\" , webhook_secret_key = \"webhook-secret-key\" , ) app = SaleorApp ( #[...] ) app . include_webhook_router ( get_webhook_details = get_webhook_details ) SUBSCRIPTION_ORDER_CREATED = \"subscription { event { ... on DraftOrderCreated { order { id status created } } } }\" @app . webhook_router . http_event_route ( SaleorEventType . ORDER_CREATED , subscription_query = SUBSCRIPTION_ORDER_CREATED ) async def order_created ( payload : Request , saleor_domain = Depends ( saleor_domain_header ) # (2) ): await do_something ( payload , saleor_domain )","title":"Support for subscription webhook payloads"},{"location":"event_handlers/http/#reinstall-the-app","text":"Neither Saleor nor the app will automatically update the registered webhooks, you need to reinstall the app in Saleor if it was already installed.","title":"Reinstall the app"},{"location":"event_handlers/sqs/","text":"AWS SQS Handlers \u00b6 Experimental SQS event handing is in the works, more content to come SQS Consumer \u00b6 The Saleor App Framework does not provide any means to consume events from an SQS queue. An SQS worker is a work in progress. Registering SQS handlers \u00b6 from saleor_app.schemas.handlers import SQSUrl @app . webhook_router . sqs_event_route ( SQSUrl ( None , scheme = \"awssqs\" , user = \"test\" , password = \"test\" , host = \"localstack\" , port = \"4566\" , path = \"/00000000/product_updated\" , ), SaleorEventType . PRODUCT_UPDATED , ) async def product_updated ( payload : List [ Webhook ], saleor_domain = Depends ( saleor_domain_header ), example = Depends ( example_dependency ), ): print ( \"Product updated!\" ) print ( payload )","title":"AWS SQS Handlers"},{"location":"event_handlers/sqs/#aws-sqs-handlers","text":"Experimental SQS event handing is in the works, more content to come","title":"AWS SQS Handlers"},{"location":"event_handlers/sqs/#sqs-consumer","text":"The Saleor App Framework does not provide any means to consume events from an SQS queue. An SQS worker is a work in progress.","title":"SQS Consumer"},{"location":"event_handlers/sqs/#registering-sqs-handlers","text":"from saleor_app.schemas.handlers import SQSUrl @app . webhook_router . sqs_event_route ( SQSUrl ( None , scheme = \"awssqs\" , user = \"test\" , password = \"test\" , host = \"localstack\" , port = \"4566\" , path = \"/00000000/product_updated\" , ), SaleorEventType . PRODUCT_UPDATED , ) async def product_updated ( payload : List [ Webhook ], saleor_domain = Depends ( saleor_domain_header ), example = Depends ( example_dependency ), ): print ( \"Product updated!\" ) print ( payload )","title":"Registering SQS handlers"},{"location":"local_app_development/","text":"Running everything locally \u00b6 Development mode \u00b6 For local development and testing you can trick the app to use a Saleor that is not behind HTTPS and also force an auth token. You shouldn't do neither in a production environment! . from pydantic import BaseSettings class Settings ( BaseSettings ): debug : bool = False development_auth_token : Optional [ str ] = None settings = Settings ( debug = True , development_auth_token = \"test_token\" , ) app = SaleorApp ( # [...] use_insecure_saleor_http = settings . debug , development_auth_token = settings . development_auth_token , ) Developing Apps on a local Saleor \u00b6 Coming soon...","title":"Running everything locally"},{"location":"local_app_development/#running-everything-locally","text":"","title":"Running everything locally"},{"location":"local_app_development/#development-mode","text":"For local development and testing you can trick the app to use a Saleor that is not behind HTTPS and also force an auth token. You shouldn't do neither in a production environment! . from pydantic import BaseSettings class Settings ( BaseSettings ): debug : bool = False development_auth_token : Optional [ str ] = None settings = Settings ( debug = True , development_auth_token = \"test_token\" , ) app = SaleorApp ( # [...] use_insecure_saleor_http = settings . debug , development_auth_token = settings . development_auth_token , )","title":"Development mode"},{"location":"local_app_development/#developing-apps-on-a-local-saleor","text":"Coming soon...","title":"Developing Apps on a local Saleor"}]}